/************************************************************************
*																		*
*  Problem 15 : D_Henry													*
*																		*
************************************************************************/
/************************************************************************
*	전자정보통신대학 컴퓨터공학부 3학년		CLC팀						*
*	20103378 임종호, 20103389 최원범, 20123426 최진성					* 
************************************************************************/

#include <stdio.h>
#include <stdlib.h>

#define MAX 2147483647 // 2^31

int gcd(int n, int m);  // 최대공약수 찾는 함수
int find_unit(int a, int b); // 헨리 알고리즘 단위 분수를 찾는 함수

/************************************************************************
*  input 데이터들을 입력받아 사이클을 형성하는 경로를 출력하는 프로그램	*
*  row와 col을 입력받아 row가 짝수일 때와 홀수 일 때를 구분하여 출력	*
************************************************************************/
int main()
{
	FILE* in_file; 
	int test_case; // test case 수
	
	in_file = fopen("input.txt", "r"); // 파일 열기
	/* 에러처리 */
	if(in_file == NULL) {
		printf("file open error\n");
		exit(1);
	}

	fscanf(in_file, "%d ", &test_case); // test case 개수 입력
	while(test_case--) {
		int a, b; // 분수와 분모

		fscanf(in_file, "%d %d", &a, &b); // 호텔의 크기와 몇번째 손님인지 입력

		printf("%d\n", find_unit(a, b)); // 헨리 알고리즘을 이용하여 맨 마지막 단위분수의 분모 출력
	}
}

/************************************************************************
*  유클리드 알고리즘을 이용한 최대공약수 찾는 함수						*
************************************************************************/
int gcd (int n, int m)
{
	if(m==0)
		return n;
	else
		return gcd(m, n%m);
}
/************************************************************************
*  분모와 분자 a, b를 입력받아 Henry의 알고리즘으로 단위 분수 출력		*
*																		*
*  파라미터																*
*  int a = 분자															*
*  int b = 분모															*
*																		*
*  반환값(return)														*
*  헨리 알고리즘의 맨 마지막 단위 분수의 분모							*
************************************************************************/
int find_unit(int a, int b)
{
	int boundary = b; // 헨리 알고리즘의 단위 분수들의 곱
	int unitFraction=2; // 단위 분수의 분모 (단위 분수의 분모는 2부터 시작)
	int g; // 최대공약수

	/* boundary는 MAX를 넘을 수 없음 */
	while(boundary <= MAX)
	{
		/* a/b가 단위 분수라면 반환 */
		if(a==1)
			return b;

		/* 단위 분수가 a/b보다 크다면 */
		if(a*unitFraction - b < 0)
		{
			/* 다음 단위 분수의 분모를 boundary에 곱했을 때 MAX를 넘지 않으면 */
			if(boundary * ++unitFraction <= MAX)
				continue;
			/* 넘으면 종료 (잘못됨)*/
			else
				break;
		}

		/* 단위분수가 a/b보다 크지 않다면 단위분수를 빼줌 a/b - 1/unitFraction */ 
		a = a*unitFraction - b;
		b *= unitFraction;

		/* 단위분수를 뺀 수의 최대공약수를 찾음 */
		g = gcd(b,a);

		/* 찾은 최대공약수로 기약분수로 만듦 */
		a /= g;
		b /= g;

		/* a/b가 단위분수가 아니면 boundary를 검사하고 다음 단위분수를 찾기 위해 */
		/* boundary에 unitFraction을 곱하고 unitFraction의 값을 올려줌			 */
		boundary *= unitFraction++;
	}

	return b; // 테스트케이스에는 여기서 리턴되는 경우가 없을 거라 생각됨
}